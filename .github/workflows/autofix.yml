name: autofix

on:
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write

jobs:
  autofix:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install stable Rust (with rustfmt)
        uses: dtolnay/rust-toolchain@stable
        with:
          components: rustfmt

      - name: Install Taplo (TOML formatter)
        uses: uncenter/setup-taplo@v1
        with:
          version: "0.8.1"

      - name: Debug git tracked files
        run: |
          echo "=== All tracked files ==="
          git ls-files
          echo ""
          echo "=== Is Cargo.toml tracked? ==="
          if git ls-files --error-unmatch Cargo.toml 2>/dev/null; then
            echo "✅ Cargo.toml IS tracked"
          else
            echo "❌ Cargo.toml is NOT tracked"
          fi

      - name: Debug Cargo.toml bytes (before)
        run: |
          set -euo pipefail
          echo "=== Cargo.toml raw bytes ==="
          xxd Cargo.toml | head -30
          echo ""
          echo "=== Cargo.toml stats ==="
          wc -c Cargo.toml
          python3 - <<'PY'
          data = open("Cargo.toml", "rb").read()
          nl = data.count(b"\n")
          cr = data.count(b"\r")
          ends_with_lf = data.endswith(b"\n")
          print(f"Size: {len(data)} bytes")
          print(f"\\n count: {nl}")
          print(f"\\r count: {cr}")
          print(f"Ends with newline: {ends_with_lf}")
          PY

      - name: Debug Cargo.toml bytes (raw URL)
        run: |
          set -euo pipefail
          python3 - <<'PY'
          import urllib.request

          url = "https://raw.githubusercontent.com/aistar-au/aistar-rs/main/Cargo.toml"
          local_data = open("Cargo.toml", "rb").read()

          try:
              with urllib.request.urlopen(url, timeout=20) as resp:
                  remote_data = resp.read()
              nl = remote_data.count(b"\n")
              cr = remote_data.count(b"\r")
              ends_with_lf = remote_data.endswith(b"\n")
              print(f"URL: {url}")
              print(f"Remote size: {len(remote_data)} bytes")
              print(f"Remote \\n count: {nl}")
              print(f"Remote \\r count: {cr}")
              print(f"Remote ends with LF: {ends_with_lf}")
              print(f"Remote == local checkout: {remote_data == local_data}")
          except Exception as e:
              print(f"⚠️  Raw URL debug skipped: {e}")
          PY

      - name: Force fix Cargo.toml line endings
        run: |
          set -euo pipefail
          python3 - <<'PY'
          from pathlib import Path

          p = Path("Cargo.toml")
          if not p.exists():
              print("❌ Cargo.toml does not exist")
              exit(1)

          data = p.read_bytes()
          nl = data.count(b"\n")
          cr = data.count(b"\r")
          print(f"Before: size={len(data)}, \\n={nl}, \\r={cr}")

          # Fix: if no line breaks, add LF at end
          if data.count(b'\n') == 0 and data.count(b'\r') == 0:
              if not data.endswith(b'\n'):
                  data = data + b'\n'
                  print("✅ Added LF terminator")
              else:
                  print("⚠️  File already ends with LF but has no internal breaks")
          # Fix: CR-only to LF
          elif data.count(b'\r') > 0 and data.count(b'\n') == 0:
              data = data.replace(b'\r', b'\n')
              if not data.endswith(b'\n'):
                  data = data + b'\n'
              print("✅ Converted CR-only to LF")
          # Fix: CRLF to LF
          elif b'\r\n' in data:
              data = data.replace(b'\r\n', b'\n').replace(b'\r', b'\n')
              if not data.endswith(b'\n'):
                  data = data + b'\n'
              print("✅ Converted CRLF to LF")
          else:
              print("⚠️  No line ending issues detected")

          p.write_bytes(data)

          # Verify
          data = p.read_bytes()
          nl = data.count(b"\n")
          cr = data.count(b"\r")
          ends_with_lf = data.endswith(b"\n")
          print(f"After:  size={len(data)}, \\n={nl}, \\r={cr}")
          print(f"Ends with newline: {ends_with_lf}")
          PY

      - name: Fix other tracked files
        run: |
          set -euo pipefail
          python3 - <<'PY'
          import subprocess
          from pathlib import Path

          TEXT_EXT = {".rs", ".toml", ".yml", ".yaml", ".md", ".txt", ".json", ".lock"}

          out = subprocess.check_output(["git", "ls-files", "-z"])
          files = [p for p in out.split(b"\0") if p]

          changed = []
          for b in files:
              name = b.decode("utf-8", "surrogateescape")
              if name == "Cargo.toml":
                  continue  # Already fixed
              p = Path(name)
              if p.suffix.lower() in TEXT_EXT:
                  try:
                      data = p.read_bytes()
                      if len(data) == 0:
                          continue
                      nl = data.count(b'\n')
                      cr = data.count(b'\r')
                      modified = None
                      if nl == 0 and cr == 0 and not data.endswith(b'\n'):
                          modified = data + b'\n'
                      elif cr > 0 and nl == 0:
                          modified = data.replace(b'\r', b'\n')
                          if not modified.endswith(b'\n'):
                              modified = modified + b'\n'
                      elif b'\r\n' in data:
                          modified = data.replace(b'\r\n', b'\n').replace(b'\r', b'\n')
                          if not modified.endswith(b'\n'):
                              modified = modified + b'\n'
                      if modified and modified != data:
                          p.write_bytes(modified)
                          changed.append(name)
                  except Exception as e:
                      print(f"⚠️  Skipping {name}: {e}")

          print(f"\n✅ Fixed {len(changed)} other file(s)")
          for x in changed[:50]:
              print(" -", x)
          PY

      - name: Verify .gitattributes exists and enforces LF
        run: |
          set -euo pipefail
          if [ ! -f .gitattributes ]; then
            echo "::error::.gitattributes not found!"
            exit 1
          fi
          grep -q 'text=auto eol=lf' .gitattributes || exit 1
          echo "✅ .gitattributes verified"

      - name: Normalize line endings (LF)
        run: |
          git add --renormalize . || true
          echo "After renormalize:"
          git status --porcelain || true

      - name: Rustfmt (apply)
        run: cargo fmt

      - name: Taplo fmt (apply)
        run: taplo fmt

      - name: Stage changes
        run: git add -A

      - name: Debug Cargo.toml bytes (after)
        run: |
          echo "=== Cargo.toml raw bytes (after) ==="
          xxd Cargo.toml | head -30
          echo ""
          python3 - <<'PY'
          data = open("Cargo.toml", "rb").read()
          nl = data.count(b"\n")
          cr = data.count(b"\r")
          ends_with_lf = data.endswith(b"\n")
          print(f"Size: {len(data)} bytes")
          print(f"\\n count: {nl}")
          print(f"\\r count: {cr}")
          print(f"Ends with newline: {ends_with_lf}")
          PY

      - name: Final debug summary
        run: |
          set -euo pipefail
          echo "=== Final Git status ==="
          git status --porcelain
          echo ""
          echo "=== Final Git diff stat ==="
          git diff --cached --stat
          echo ""
          CHANGED=$(git status -s | wc -l)
          echo "Total git changes: $CHANGED"
          if [ "$CHANGED" -eq 0 ]; then
            echo "::warning::No changes detected"
          fi

      - name: Detect whether PR changes exist
        id: detect_changes
        run: |
          set -euo pipefail
          if git diff --cached --quiet; then
            echo "has_changes=false" >> "$GITHUB_OUTPUT"
            echo "No staged changes; skipping PR creation."
          else
            echo "has_changes=true" >> "$GITHUB_OUTPUT"
            echo "Staged changes detected; PR will be created."
          fi

      - name: Create PR
        if: steps.detect_changes.outputs.has_changes == 'true'
        uses: peter-evans/create-pull-request@v6
        with:
          commit-message: "chore: fix line endings + formatting"
          title: "chore: fix line endings + formatting"
          body: |
            Automated fixes:
            - Added missing line terminators (LF)
            - Converted CR-only/CRLF -> LF
            - cargo fmt + taplo fmt
          branch: autofix/formatting
          delete-branch: true

      - name: No-op summary
        if: steps.detect_changes.outputs.has_changes != 'true'
        run: echo "No formatting/line-ending delta found relative to main; PR not created."
